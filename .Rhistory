lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
x[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9])))
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9])))
lines(x,y3,col="green")  # coś nie działa
View(z)
newdata=data.frame(z=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9]))
View(newdata)
newdata=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9])
View(newdata)
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9])))
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9]))
lines(x,y3,col="green")  # coś nie działa
source("~/.active-rstudio-document", echo=TRUE)
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
#y3 <- predict(lm3, newdata=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9]))
y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
#y3 <- predict(lm3, newdata=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9]))
y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z[,1], z[,2], z[,3], z[,4], z[,5], z[,6], z[,7], z[,8], z[,9]))
#y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z)
#y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(Z=z)
#y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(Z=z))
#y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 <- predict(lm3, newdata=data.frame(z))
#y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
X <- runif(1000, 0, 1)
Y <- X^3 + rnorm(1000, 0, 0.1)
lm1 <- lm(Y ~ X)
lm2 <- lm(Y ~ I(X^3))
Z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
Z[,j+1] = ((j/10 < X)&(X <= (j+1)/10))
}
#lm3 <- lm(Y ~ Z)
lm3 <- lm(Y ~ Z[,1] + Z[,2] + Z[,3] + Z[,4] + Z[,5] + Z[,6] + Z[,7] + Z[,8] + Z[,9])# + Z[,10])
x <- seq(0,1,length.out=1000)
plot(Y ~ X)
#y1 <- coef(lm1)[1] + coef(lm1)[2]*x
y1 <- predict(lm1, newdata=data.frame(X=x))
y2 <- predict(lm2, newdata=data.frame(X=x))
lines(x,y1,col="blue")
lines(x,y2,col="red")
z = matrix(0,ncol=10,nrow=1000)
for(j in 0:9){
z[,j+1] = ((j/10 < x)&(x <= (j+1)/10))
}
y3 = coef(L4)[1]+coef(L4)[2]*z[,1]+coef(L4)[3]*z[,2]+coef(L4)[4]*z[,3]+coef(L4)[5]*z[,4]+coef(L4)[6]*z[,5]+coef(L4)[7]*z[,6]+coef(L4)[8]*z[,7]+coef(L4)[9]*z[,8]+coef(L4)[10]*z[,9]
lines(x,y3,col="green")  # coś nie działa
library(scatterplot3d)
library(scatterplot3d)
install.packages("scatterplot3d")
library(scatterplot3d)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$SpeciesCode <- as.numeric(factor(df$Species))
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$SpeciesCode <- as.numeric(factor(df$Species))
library(scatterplot3d)
library(faraway)
data(Gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$SpeciesCode <- as.numeric(factor(df$Species))
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$SpeciesCode <- as.numeric(factor(df$Species))
df=data(gala)
library(scatterplot3d)
library(faraway)
df=data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$SpeciesCode <- as.numeric(factor(df$Species))
library(scatterplot3d)
library(faraway)
df=data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$SpeciesCode <- as.numeric(factor(df$Species))
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
gala$SpeciesCode <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(df$SpeciesCode, df$Elevation, df$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
SpeciesCode <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(df$SpeciesCode, df$Elevation, df$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
SpeciesCode <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(SpeciesCode, gala$Elevation, gala$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
gala$Species <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(SpeciesCode, gala$Elevation, gala$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
gala$Species <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(gala$Species, gala$Elevation, gala$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
gala$Species <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(gala$Species, gala$Elevation, gala$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
gala$Species <- as.numeric(factor(gala$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(df$Species, df$Elevation, df$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$Species <- as.numeric(factor(df$Species))
# Tworzenie wykresu 3-wymiarowego
scatterplot3d(df$Species, df$Elevation, df$Nearest,
xlab = "Species", ylab = "Elevation", zlab = "Nearest")
library(scatterplot3d)
library(faraway)
data(gala)
# Przekształcenie zmiennej kategorycznej Species na numeryczną
df$Species <- as.numeric(factor(df$Species))
lm1 <- lm(gala$Species ~ gala$Area)
summary(lm1)
#Zad 6
summary(model)
#Zad 6
summary(model)
library(faraway)
data=gala
model <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data=data)
residuals <- resid(model)
sum_of_squares <- sum(residuals^2)
model.matrix(model)
# obliczenie liczby stopni swobody
n <- nrow(model.matrix(model1)) #liczebność próby
#Zad 6
summary(model)
library(faraway)
data=gala
model <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data=data)
residuals <- resid(model)
sum_of_squares <- sum(residuals^2)
model.matrix(model)
# obliczenie liczby stopni swobody
n <- nrow(model.matrix(model1)) #liczebność próby
library(faraway)
data=gala
model <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data=data)
residuals <- resid(model)
sum_of_squares <- sum(residuals^2)
model.matrix(model)
# obliczenie liczby stopni swobody
n <- nrow(model.matrix(model1)) #liczebność próby
# a) Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
# b) dla Elevation beta=0.319465, przy pvalue=3.82e-06 zatem odrzucamy hipotezę zerową o tym, ze beta = 0.55
t.test(model$coefficients[2], mu = 0.55)
# a) Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
t.test(model$coefficients[2])
# a) Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
t.test(summary(model)coefficients[2])
#Zad 6
summary(model)
# a) Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
summary(model)$coefficients[2]
# a) Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
summary(model)$coefficients[3]
# a) Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
t.test(summary(model)$coefficients[3]-0.55)
library(faraway)
data=gala
model <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data=data)
residuals <- resid(model)
sum_of_squares <- sum(residuals^2)
model.matrix(model)
# obliczenie liczby stopni swobody
n <- nrow(model.matrix(model1)) #liczebność próby
tval <- (summary(model)$coefficients["Elevation", "Estimate"] - 0.55) / summary(model)$coefficients["Elevation", "Std. Error"]
pval <- 2 * pt(-abs(tval), df = summary(model)$df.residual)
tval <- (summary(model)$coefficients["Elevation", "Estimate"] - 0.55) / summary(model)$coefficients["Elevation", "Std. Error"]
#pval <- 2 * pt(-abs(tval), df = summary(model)$df.residual)
c(summary(model)$coefficients["Elevation", c("Estimate", "Std. Error", "t value")], pval)
library(faraway)
data=gala
model <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data=data)
residuals <- resid(model)
sum_of_squares <- sum(residuals^2)
model.matrix(model)
# obliczenie liczby stopni swobody
n <- nrow(model.matrix(model1)) #liczebność próby
library(faraway)
data=gala
model <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data=data)
residuals <- resid(model)
sum_of_squares <- sum(residuals^2)
model.matrix(model)
# obliczenie liczby stopni swobody
n <- nrow(model.matrix(model)) #liczebność próby
p <- length(coef(model)) #liczba parametrów modelu
df <- n - p - 1  #liczba stopni swobody
residual_standard_error <- sqrt(sum_of_squares / df)
print(residual_standard_error)
print(summary(model)$sigma)
#Zad 6
#a)
summary(model)
# Estimate dla Area jest równy beta=-0.023938, przy pvalue=0.2963 > 0.05 zatem nie odrzucamy hipotezy zerowej o tym, ze beta=0
#b)
tval <- (summary(model)$coefficients["Elevation", "Estimate"] - 0.55) / summary(model)$coefficients["Elevation", "Std. Error"]
pval <- 2 * pt(-abs(tval), df = summary(model)$df.residual)
#We are going to fit a simple neural network using the neuralnet package and fit a linear model as a comparison.
#The Boston dataset is a collection of data about housing values in the suburbs of Boston. Our goal is to predict the median value of owner-occupied homes (medv) using all the other continuous variables available.
set.seed(500)
library(MASS)
data <- Boston
#First we need to check that no datapoint is missing, otherwise we need to fix the dataset.
apply(data,2,function(x) sum(is.na(x)))
install.packages("neuralnet")
library(ggplot2)
rm(list=ls())
library(ggplot2)
install.packages("ggplot2")
install.packages("rtools")
library(ggplot2)
#Wczytanie zbioru danych
data <- read.csv("Dylag1.csv")
setwd("~/GitHub/Econometrics")
#Wczytanie zbioru danych
data <- read.csv("Dylag1.csv")
